---
layout: post
title: Sorry, You're Just Not My Type
date: 2008-02-04 02:41:33.000000000 -07:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1441453170'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:2:"72";s:5:"score";s:17:"19.25550893438473";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:2:"78";s:5:"score";s:18:"17.799031933669884";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"190";s:5:"score";s:18:"16.822718285597812";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:2:"84";s:5:"score";s:18:"16.555655500376353";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:2:"59";s:5:"score";s:18:"13.193861747681794";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"156";s:5:"score";s:18:"13.105919992352758";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:3:"151";s:5:"score";s:18:"12.593652562643186";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:2:"44";s:5:"score";s:18:"12.556954285320586";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p><a href="http://szeryf.wordpress.com/2008/01/07/does-stubbing-make-your-tests-brittle/">szeryf asks</a> if stubbing makes your tests brittle.  His widely-shared concern is that mocks and stubs couple your tests to the implementation.</p>
<p>Here&#8217;s a little example:</p>
<p><script src="http://gist.github.com/495260.js?file=gistfile1.rb"></script>
<p>Looks pretty standard to me.  What if I decide to call <em>#any_overdue?</em> instead of <em>#count_overdue</em> on it though?</p>
<p><script src="http://gist.github.com/495262.js?file=gistfile1.rb"></script>
<p>bzzzzzzt.  The spec blows up because the <em>repo</em> stub doesn&#8217;t have a <em>#any_overdue?</em> method.  Our test sucks because it&#8217;s coupled to the implementation.</p>
<p>Is it really?</p>
<p>This situation is a lot like breaking up with a girl when things seem to be going perfectly fine.</p>
<p>&#8220;Sorry babe, I need a girl who can go to dingy dive bars.&#8221;</p>
<p>&#8220;I &#8211; I can go to dive bars *sniff*&#8221;</p>
<p>There&#8217;s nothing wrong with the mock, it was simply asked to do something that it didn&#8217;t know it should do.</p>
<p>As great as duck-typing is, it can be easy to forget that there are still types in Ruby.  I&#8217;m going to go ahead and invent some new terms (I think):</p>
<ul>
<li>an object&#8217;s <strong>potential type</strong> is the collection of methods it responds to</li>
<li>an object&#8217;s <strong>effective type</strong> is the collection of methods that are actually invoked in some usage of the object</li>
</ul>
<p>To be honest, I don&#8217;t really like the term &#8220;potential type,&#8221; but fortunately Ruby lets us ignore it most of the time anyway.</p>
<p>Let&#8217;s pretend for a moment that Ruby is a statically-typed language, Java&#8217;s hot-but-stuck-up cousin.</p>
<p><script src="http://gist.github.com/495264.js?file=gistfile1.rb"></script>
<p>*shudder*</p>
<p>If we wanted to write a stub object that implements the Aggregator protocol, it would have to implement both methods, even if our test only made use of one of them.  In fact, that&#8217;s exactly what all the Java dudes did for a long time, and still do on occasion.</p>
<p>Because Matz is nice, we only have to worry about the effective protocol.  This can lead to some misunderstandings when an object doesn&#8217;t implement a wider protocol.  Keep in mind there&#8217;s nothing magical about stubs - RSpec&#8217;s stubbing framework just lets you define objects on the fly that implement a particular protocol.</p>
<p>Tests that use stubs don&#8217;t inherently rely on the production code&#8217;s implementation, they rely on a protocol.  You can write sucky tests that rely on the implementation whether or not you use stubs.</p>
<p>This is the real world though, not some la-la land where mock objects get butt hurt because of hidden expectations.  The original example pointed out that stubs suck because you can&#8217;t change a method&#8217;s implementation to use <em>exist?</em> instead of <em>count</em> without changing the stub as well.  So what should we do?</p>
<p>One option is to develop a library to stub out commonly used protocols.  That&#8217;s what the <a href="http://www.mockobjects.com/">Mock Objects guys</a> do with Java&#8217;s servlet API.  There&#8217;s <a href="http://www.dcmanges.com/blog/rails-unit-record-test-without-the-database">a project</a> that tries to do this with ActiveRecord, though I haven&#8217;t looked at it closely enough to know if it goes all the way towards solving AR testing issues.</p>
<p>The other option is just to ignore it and deal with the occasional pain of using stubs.  That&#8217;s what I do, because Ruby and Rails give me enough that it&#8217;s not overly painful.  And since it&#8217;s just programming, we can use standard programming techniques to manage and reduce any pain even further.</p>
<p>Another alternative of course is to not use stubs at all.  That is a valid position as well.  I just want people to be aware that there&#8217;s nothing inherently wrong with using mocks and stubs, just as there&#8217;s nothing inherently wrong with using a database in your unit tests.  It&#8217;s all a bunch of tradeoffs, and you have to make the decisions that are right for your team and your project.</p>
