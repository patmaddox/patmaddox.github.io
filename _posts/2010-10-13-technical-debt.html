---
layout: post
title: Technical Debt
date: 2010-10-13 18:01:33.000000000 -06:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1443697900'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:3:"951";s:5:"score";s:17:"21.19893577385423";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:3:"176";s:5:"score";s:18:"20.353222072310714";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"180";s:5:"score";s:18:"14.937121670051123";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:4:"1101";s:5:"score";s:18:"11.193517316096218";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:2:"76";s:5:"score";s:17:"9.953467484841148";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"230";s:5:"score";s:17:"8.888158296178068";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:3:"226";s:5:"score";s:17:"8.888158296178068";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:3:"101";s:5:"score";s:17:"8.567173123721258";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>At RailsConf 2009, BJ Clark and I gave a talk about <a href="http://www.slideshare.net/scidept/working-effectively-with-legacy-code">working with legacy Rails apps</a>.  In that talk, we spent some time talking about technical debt.  <a href="http://c2.com/doc/oopsla92.html">Ward Cunningham originally coined the term 18 years ago</a>, and it has enjoyed a resurgence in blog posts and conference talks throughout the past year.</p>
<p>I&#8217;ve noticed that most discussions about technical debt, including BJ&#8217;s and mine, miss the mark when it comes Ward&#8217;s original point.</p>
<p>Ward invented the Debt Metaphor to explain how a software project benefits from delivering software early on in the project&#8217;s lifecycle.  He was working on WyCash, an investment portfolio system that modeled a complex set of financial instruments.  Because Ward and the rest of the programming team were programmers and not financial experts, a good deal of their effort went into learning the complexities of the domain they were working in.  This sort of learning is best done iteratively, by creating software and observing how it works, and then taking what you learn and investing it back into the software.  Steve Freeman, listening to Ward speak about technical debt, <a href="http://stevef.truemesh.com/archives/2004_10.html">captured this process</a>:</p>
<ul>
<li>Use what you know</li>
<li>Feel it work</li>
<li>Share the experience</li>
<li>Wait for insight</li>
<li>Refactor to include it</li>
</ul>
<p>The most interesting bit to me is &#8220;refactor to include insight.&#8221;  We tend to interpret refactoring as <a href="http://martinfowler.com/books.html#refactoring">improving the design of existing code</a>, but if you listen to Ward talk it&#8217;s clear that he literally means changing the factorization of the code over time.  As his team learned about the problem, they modified the program &#8220;to look as if we had known what we were doing all along, and to look as if it had been easy to do.&#8221;  It was crucial to him that the software reflect the team&#8217;s current understanding of the problem, and that it be continually updated to reflect any new insights they learned.</p>
<p>So where does the debt metaphor come into play?  At the begining of the project, the programming team knows very little about the domain problem.  Any code they write will look very different just a few iterations later.  Writing code before you have a complete understanding of the problem allows you to jumpstart a project.  It&#8217;s like taking out a loan, which allows you to get moving sooner than if you had to have all of the necessary capital upfront.</p>
<p>Technical Debt is not a license to write bad code with the intention of cleaning it up later.  In fact, successfully using the Technical Debt metaphor hinges upon a team&#8217;s ability to write clean code.  The code needs to clearly and concisely reflect the team&#8217;s current understanding of the problem, so that as they learn more they can easily modify the program to reflect their new understanding.  It&#8217;s important to make sure the code doesn&#8217;t drift from the team&#8217;s understanding of the problem.  Failure to do so, as Ward puts it, results in &#8220;continually stumbling over the disagreement [between code and understanding], which slows us down and is like paying interest.&#8221;</p>
<p>Other interpretations of technical debt suggest that interest payments come from the time taken to understand ugly code.  That wasted time, and the bugs that typically come out of ugly code, are more like penalties on the debt.  Whenever a team has to deal with ugly, buggy code, they are penalized for not writing the cleanest code they possibly can.</p>
<p><a href="http://michaelfeathers.typepad.com/michael_feathers_blog/2008/08/beyond-technica.html">Michael Feathers gets it right</a> when he says, &#8220;we need to see clean flexible code as an asset and count it as an asset.&#8221;  Ward believes this is the practical approach, but as a lot of folks know it often turns out to be much harder in practice.  Whether it&#8217;s deadlines, dispersed teams, or unfamiliarity with a new set of libraries or technologies, it&#8217;s easy to let code rot.</p>
<p>Keep this in mind the next time you hear someone talk about technical debt.  It sounds great in theory, and if you listen to Ward&#8217;s words it makes a lot of sense.  Let me caution you, though, to beware of any suggestion that it&#8217;s okay to commit unclean code, even in the name of shipping sooner.  Software development is difficult enough as is, and we already have a term for giving undue weight to our present situation versus the future: <em>being irresponsible</em>.</p>
<p>Also, be sure to check out <a href="http://www.youtube.com/watch?v=pqeJFYwnkjE&amp;feature=player_embedded">Ward&#8217;s video explanation of the Debt Metaphor</a></p>
