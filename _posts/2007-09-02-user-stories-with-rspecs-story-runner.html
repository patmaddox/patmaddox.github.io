---
layout: post
title: User Stories With RSpec's Story Runner
date: 2007-09-02 01:18:33.000000000 -06:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1442001989'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:2:"44";s:5:"score";s:17:"23.08624637198845";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:3:"230";s:5:"score";s:17:"20.09521662550526";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"160";s:5:"score";s:18:"19.457781721938574";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:3:"260";s:5:"score";s:18:"18.601513906262337";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"119";s:5:"score";s:17:"17.31766958984874";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:2:"82";s:5:"score";s:18:"16.966624111676943";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:3:"199";s:5:"score";s:16:"16.6150103599797";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:3:"158";s:5:"score";s:18:"14.743174708197115";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>If you&#8217;ve been using <a href="http://rspec.rubyforge.org/">RSpec</a> in your Rails apps, you know that it&#8217;s an excellent tool to help drive the design of your code at the object level.  However if you wanted to do integration or acceptance testing, you&#8217;d have to use Rails&#8217; Test::Unit <a href="http://weblog.jamisbuck.org/2006/3/9/integration-testing-in-rails-1-1">integration tests</a> or rely on an external framework such as <a href="http://www.openqa.org/selenium/">Selenium</a> or <a href="http://wtr.rubyforge.org/">Watir</a>.  RSpec has bindings for both Selenium and Watir, but both frameworks require a browser to run thus are quite heavy-weight.</p>
<p>A few days ago, <a href="http://rubyforge.org/pipermail/rspec-devel/2007-August/003756.html">David Chelimsky announced</a> that RSpec&#8217;s Story Runner now works with the rspec_on_rails plugin.  Story Runner is the result of Dan North&#8217;s hard work to merge his <a href="http://dannorth.net/2007/06/introducing-rbehave">rbehave</a> project into RSpec.  This gives us the ability to write <a href="http://c2.com/cgi/wiki?AcceptanceTest">acceptance tests</a> using RSpec&#8217;s expressive expectations.  In addition, Story Runner provides a structure for your stories (acceptance tests) that helps clearly express the assumptions and expectations of your code.</p>
<p>You might be familiar with the &#8220;Given&#8230;When&#8230;Then&#8230;&#8221; structure of a story.  If not (I wasn&#8217;t), Dan North has a great explanation of <a href="http://dannorth.net/whats-in-a-story">what goes in a story</a>.</p>
<p>Now that you have some background on user stories, I&#8217;ll show you an example of an integration test I wrote with Test::Unit a while back and then converted to use Story Runner earlier today.</p>
<p>The most fundamental user story we have is a user viewing his home page.  A user&#8217;s home page shows information that&#8217;s important to him, and only that information that is available to him.  So for example the root user should be able to see all the companies in the system, all the videos, etc.  A regular user would only see videos that belong to his company.  A reseller would see videos belonging to all children companies.</p>
<p>Here&#8217;s my integration tests written in Test::Unit.  I factored out the code into a DSLish<sup><a href="#dsl">1</a></sup> library so that the tests read easily.</p>
<p><script src="http://gist.github.com/482433.js?file=gistfile1.rb"></script>
<p>Personally I like how the stories read.  They&#8217;re tiny (only 6 lines) and read very easily.  I factored out some things to read more like English so that our QA guy<sup><a href="#qa-or-customer">2</a></sup> could better understand them.  Hopefully as time goes on we&#8217;ll create enough helper methods that he can write some of his own tests.</p>
<p>Despite how sexy the tests are, there were some things that I found a bit unsettling as I wrote them.</p>
<ul>
<li>The code reads very well, but it&#8217;s still code.  This can be a mental block for a QA person.  My dream of having our QA guy write his own tests is likely a pipe dream, unless we hire a QA person who is also jazzed about Ruby.</li>
<li>Factoring things out so that it looks like English could easily lead to bugs.  The particular example I showed is quite simple, but other stories will contain much more complex setup.  You can see that I got a tiny bit clever in writing my &#8220;with(1).video&#8221; chain.  That code is 100% untested.  I do not have enough confidence to write tons of untested code for complex situations, particularly when my actual test code relies on it!</li>
</ul>
<p>After thinking through those two points it seems like my biggest problem is trying to extract a DSL so that a non-programmer can write tests.  My code is error-prone, and it&#8217;s not likely to be used like that anyway, so if I could just abandon that hope then maybe Test::Unit would suffice.  But then I&#8217;d have assert_template littered throughout my tests.  eww.</p>
<p>So I was pretty excited when I heard that Story Runner can be used with Rails apps.  Without further ado, here are those same stories converted to Story Runner format.</p>
<p><script src="http://gist.github.com/482434.js?file=gistfile1.rb"></script>
<p>The first thing that you&#8217;ll probably notice is that it&#8217;s a lot more verbose than the corresponding Test::Unit test.  You might love it or hate it or not really care, that&#8217;s going to be a matter of personal preference.  Even though it&#8217;s more verbose, it&#8217;s not much longer than Test::Unit.  TU comes in at 105 lines and Story Runner at 114.  But the Story Runner version tests for some things that the TU version doesn&#8217;t, such as testing that video titles and company names show up on the proper pages.  I think if I were to take those expectations out then it would actually be shorter than the TU version.</p>
<p>What does it mean then if Story Runner is shorter but more verbose than Test::Unit?  To me it means that Story Runner gets closer to the problem domain.  This is evident in how much infrastructure code I had to write.  In the 105 line TU file, 60 of those lines just create the DSL I use for the tests.  In comparison, the Story Runner version has 14.  I had to write lots of code to support my tests so that they could be in a language as close to the problem domain as I want.  Code that I&#8217;m too lazy to test thus is prone to lots of errors.  Story Runner on the other hand gives me the language I want right off the bat, and it&#8217;s all tested to boot!</p>
<p>Right there we&#8217;ve killed off my biggest objection to integration testing with Test::Unit.  Most of my test code uses RSpec&#8217;s library to test my code.  I have very little untested infrastructure code, and the little bit I do have is trivial.</p>
<p>My other objection was that the tests were still too much code for a QA person to handle.  Story Runner gets around this by using plain strings everywhere.  Ideally your QA people will have the ability to generate sentence fragments, which is basically all it takes to write a story in RSpec.</p>
<p>I don&#8217;t expect my tester to write actual test code.  But with Story Runner he can, or at least get close.  He can easily write</p>
<p><script src="http://gist.github.com/482436.js?file=gistfile1.rb"></script>
<p>When he runs that, one of three things will happen:</p>
<ol>
<li>The test will pass.  yay!</li>
<li>The test will fail with an error message that he understands</li>
<li>The test will blow up with an error message that makes no sense</li>
</ol>
<p>Story Runner puts the tester in a unique position to handle scenarios 2 and 3.  Let&#8217;s say that the test fails, and because of the error message, the tester determines that some setup code hasn&#8217;t been written.  Perhaps the &#8220;two existing videos&#8221; given hasn&#8217;t been implemented anywhere.  If he&#8217;s feeling brave, he can go ahead and attempt it himself.  Now we have a fully-functioning acceptance test that the developers can use to complete the feature.  If the tester can&#8217;t figure it out, he can just add a pending command:</p>
<p><script src="http://gist.github.com/482438.js?file=gistfile1.rb"></script>
<p>He can spend two minutes trying to complete the test and just move on if he doesn&#8217;t succeed.  Now as a developer I can go in and implement the setup code.  I know exactly what to do because he wrote it in plain English.  Which brings me to the next benefit of Story Runner-style tests, and it&#8217;s a huge one.</p>
<p>All assumptions and expectations are clearly documented.</p>
<p>I didn&#8217;t appreciate this benefit until I had finished writing the stories.  I wrestled with how much more verbose the stories were than their Test::Unit cousins.  Then I realized just how much more information they actually gave me.  Operating under a certain set of assumptions, when a particular action is performed I expect certain outcomes.  Or more succinctly, Given&#8230;When&#8230;Then.</p>
<p>I remember when I was about 8 years old my mother had made one of her amazing pumpkin cheesecakes.  I took a big ol&#8217; slice and enjoyed it until she yelled at me.  She had made the pie for one of those mom clubs, but I assumed it was for our family.  This is when I first heard, &#8220;You know what happens when you assume&#8230;you make an ass out of u and me.&#8221;</p>
<p>So <a href="http://www.google.com/search?q=assumptions+in+programming&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=org.mozilla:en-US:official&amp;client=firefox-a">assumptions are kind of a big deal</a>, especially in programming.  <a href="http://blog.daveastels.com/">Dave Astels</a> even goes so far as to say that if the reader of your code makes ungrounded assumptions, then <a href="http://blog.daveastels.com/?p=5">your code sucks</a>:</p>
<div class="quote"><q>If the name is missleading (sic), the reader can make ungrounded assumptions about what&#8217;s happening in the code, leading to misunderstanding, and eventually bugs.</q></div>
<p>If your test stories don&#8217;t outline their assumptions, then they&#8217;re merely anecdotes, not stories.  The reader can take away whatever the hell he wants from them.  Assumptions are what ground the stories to reality and give them communication value.  When you have a story structure that requires you to express assumptions, you don&#8217;t end up with unspoken ones.  Those times where a communication error results from an unspoken, ungrounded assumption, it becomes trivial to express the assumption in the test and avoid those communication problems in the future.</p>
<p>I&#8217;ve only played with Story Runner for a little bit, but I&#8217;m excited because already I can see how it will help me avoid a number of coding problems and communication problems.  And since problems in software development basically fall into either coding or communication, it&#8217;s nice to have a tool that helps me avoid them.</p>
<p><a href="http://behaviour-driven.org/">BDD</a> comes in two flavors, you could say.  RSpec has supported BDD at the object level, helping you specify interactions between objects and the outcomes of operations.  However up until recently it wasn&#8217;t practical for specifying the behavior of a system from the user&#8217;s perspective.  With the new Story Runner, RSpec is a complete BDD framework.</p>
<h2>Update: Output from integration tests and stories</h2>
<p>Another benefit of Story Runner is that it gives you helpful output.  You could literally send the output to a customer for verification.</p>
<h3>Integration test:</h3>
<pre><code>$ ruby test/integration/user_stories_test.rb 
Loaded suite test/integration/user_stories_test
Started
....
Finished in 1.186151 seconds.

4 tests, 16 assertions, 0 failures, 0 errors</code></pre>
<h3>Story Runner</h3>
<pre><code>$ ruby stories/view_home_page.rb 
Running 4 scenarios:
Story: View Home Page

  As a user
  I want to view my home page
  So that I can get a birds eye view of the system


Scenario: Publisher with no videos

  Given a company named No Videos
  And a user named novideos
  And the user belongs to company,No Videos
  And logged in as novideos

  When visiting /

  Then viewer should see companies/show_initial
.
Scenario: Root user

  Given a user named admin
  And a company named Company1
  And a company named Company2
  And the user has the role root
  And logged in as admin

  When visiting /

  Then viewer should see main/root_home
  And page should show company named Company1
  And page should show company named Company2
.
Scenario: Publisher with one video

  Given a user named publisher
  And a company named Has Videos
  And the user belongs to company,Has Videos
  And # published videos belonging to company Has Videos,2
  And logged in as publisher

  When visiting /

  Then viewer should see main/user_home
  And page should show video titled Has Videos 1
  And page should show video titled Has Videos 2
.
Scenario: Reseller user

  Given a user named reseller
  And a reseller named Big Bad Reseller
  And the user belongs to reseller,Big Bad Reseller
  And a company named Resold
  And the company belongs to reseller Big Bad Reseller
  And # published videos belonging to company Resold,1
  And a company named Indy
  And # published videos belonging to company Indy,1
  And logged in as reseller

  When visiting /

  Then viewer should see main/reseller_home
  And page should show company named Resold
  And page should not show company named Indy
  And page should show video titled Resold 1
  And page should not show video titled Indy 1
.



4 scenarios: 4 succeeded, 0 failed, 0 pending</code></pre>
<p>You&#8217;ll notice there are a couple funky parts related to passing values to blocks.  For example, &#8220;Given # of published videos belonging to company Resold,1&#8221; is a bit awkward.  I have a feeling we&#8217;ll fix that in the coming weeks.  Perhaps something like</p>
<table class="CodeRay">
<tr>
<td class="line_numbers" title="click to toggle" onclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }">
<pre><tt>
</tt></pre>
</td>
<td class="code">
<pre ondblclick="with (this.style) { overflow = (overflow == 'auto' || overflow == '') ? 'visible' : 'auto' }"><span class="co">Given</span> <span class="s"><span class="dl">"</span><span class="k">%{num_videos} published video belonging to company '%{company_name}'</span><span class="dl">"</span></span>, <span class="i">1</span>, <span class="s"><span class="dl">"</span><span class="k">Resold</span><span class="dl">"</span></span> <span class="r">do</span> |num_videos, company_name|</pre>
</td>
</tr>
</table>
<p>Which would produce a more natural &#8220;Given 1 published video belonging to company &#8216;Resold&#8217;&#8221;</p>
<p>Over all the output is much nicer and uses the ideal language for communicating with a customer.  &#8220;This story is comprised of four scenarios, and as you can see, they all work.&#8221;</p>
<hr />
<p><a name="dsl">1</a>. I don&#8217;t really like the term DSL, since <a href="http://www.oreillynet.com/ruby/blog/2005/12/what_is_a_dsl.html">nobody</a> <a href="http://www.groovie.org/articles/2005/12/08/is-rails-a-dsl-what-is-a-dsl-and-is-it-possible-in-python">really</a> <a href="http://blog.moertel.com/articles/2007/08/18/seven-signs-you-may-have-created-a-gratuitous-domain-specific-language">knows</a> <a href="http://www.infoq.com/news/2007/06/dsl-or-not">wtf</a> <a href="http://www.martinfowler.com/bliki/DomainSpecificLanguage.html">it means</a><br /><a name="qa-or-customer">2</a>. I say QA guy, but this all applies the same if you&#8217;re working directly with a customer</p>
