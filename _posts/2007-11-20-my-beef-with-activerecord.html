---
layout: post
title: My Beef With ActiveRecord
date: 2007-11-20 02:25:04.000000000 -07:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1441640193'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:3:"240";s:5:"score";s:18:"16.412737572549993";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:2:"86";s:5:"score";s:18:"15.534004252844372";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"125";s:5:"score";s:18:"15.245803564745135";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:4:"1007";s:5:"score";s:18:"15.237164242607825";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:2:"80";s:5:"score";s:18:"14.370814863618733";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"199";s:5:"score";s:17:"13.71426392453639";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:2:"99";s:5:"score";s:17:"13.71426392453639";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:3:"463";s:5:"score";s:18:"12.695939279304941";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>I&#8217;ve mentioned before that I have a little beef with Rails&#8217;s ActiveRecord.  The symptom is that it&#8217;s difficult to test well, and the problem is that it mixes business and persistence logic.</p>
<p>I discovered another symptom today.  This is something that has bothered me for over a year, and it never actually hit me until today.</p>
<p>Let&#8217;s say we&#8217;ve got the following Person class:</p>
<p><script src="http://gist.github.com/482495.js?file=gistfile1.rb"></script>
<p>In the fictionary app in which a Person lives, one business rule is that each Person must have a name.  Rails lets us clearly express that with validates_presence_of.</p>
<p>The problem is that this business rule is not enforced until the record is actually saved.  This means that</p>
<p><script src="http://gist.github.com/482496.js?file=gistfile1.rb"></script>
<p>is a perfectly valid sequence.  I don&#8217;t know about you, but I find that downright offensive.  A Person can&#8217;t correctly perform its own operations, much less reliably collaborate with other objects.  You can also commit such atrocities as</p>
<p><script src="http://gist.github.com/482497.js?file=gistfile1.rb"></script>
<p>Objects should be initialized to a valid state.  Ignoring that rule is bad.  At best, you end up littering your code with all kinds of senseless error checking.  At worst, you end up with strange bugs and corrupt data.</p>
<p>I&#8217;ve been very deep in Rails-land for the past couple years, which I think is why it just clicked tonight.  I wanted to experiment with writing my app in plain Ruby and then converting domain classes to AR.  I had a spec that looked something like:</p>
<p><script src="http://gist.github.com/482498.js?file=gistfile1.rb"></script>
<p>When I converted it to AR, I had to toss that spec.  That&#8217;s when I realized that AR doesn&#8217;t enforce the business rules until an object gets saved.  That might be fine if your application is 100% CRUD, but I don&#8217;t think I&#8217;ve ever seen one of those.  There&#8217;s always <em>something</em> happening besides just CRUD.  Enforcing business rules when an object gets saved is way too late - by then it could have taken place in several interactions.</p>
<p>You don&#8217;t want your code to use objects that are invalid.  They behave unreliably and are worthless.  The easiest way to ensure that objects don&#8217;t become invalid is by making those objects enforce business rules.</p>
<p>It&#8217;s important to cleanly separate responsibilities.  AR is focused on shuttling data in and out of a relational database, and layering some business logic on top.  I wouldn&#8217;t say those are necessarily competing concerns, but it&#8217;s easy to see how they might push an object in different directions.  Even just at a conceptual level, my life is easier when I&#8217;m only thinking about one thing at a time.</p>
