---
layout: post
title: ";edit Considered Harmless"
date: 2007-04-12 00:29:54.000000000 -06:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1441843365'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:2:"96";s:5:"score";s:18:"25.625457480714598";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:2:"53";s:5:"score";s:18:"25.179170378127555";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:2:"78";s:5:"score";s:17:"16.24735414069425";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:2:"50";s:5:"score";s:18:"15.601807356319874";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"115";s:5:"score";s:18:"15.534004252844372";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:2:"70";s:5:"score";s:18:"14.215512995158603";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:4:"1007";s:5:"score";s:18:"13.404582778859513";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:3:"160";s:5:"score";s:18:"12.382931531410293";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>Dave Thomas discusses an <a href="http://pragdave.pragprog.com/pragdave/2007/03/the_radar_archi.html">interesting architecture for web applications</a>.  You create two applications - one that does all the work you need and represents its data as XML, and one that presents it in a browser-friendly format.  The reasoning behind it is that web browsers are stupid. Fat clients can read and interpret XML directly from the main app and do whatever they want based on it.  Display it in editable form, post it back to the server to create or update resources, etc.  Browsers will need to interact with the presentation app to help users manipulate the resources.</p>
<p>I think it&#8217;s a cool idea.  I doubt most apps need it, but once you get to a point where you&#8217;re dealing with lots of different resources, it might be nice to have.  It lets you keep the business logic completely separate from the presentation layer.  Personally, <a href="http://c2.com/cgi/wiki?ModelViewController">MVC</a> works just fine  at this point, but I can envisage a scenario where RADAR would be useful.</p>
<p>What I don&#8217;t understand is why people have an issue with the ;edit-style URLs -  http://example.com/articles/1;edit.  Dave writes:</p>
<div class="quote"><q>However, I personally think it was optimistic to try to treat the two styles of interaction (smart and dumb clients) using the same protocol. The ugliness of the ;xxx appendages was a hint.</q></div>
<p>Robert Hahn <a href="http://blog.roberthahn.ca/articles/2007/04/06/url-design">addresses the URL problem</a> in his 3 Rules of URI Design.  I happen to like Rule #1, I use Rule #3 where it makes sense, and I think he&#8217;s dead wrong with Rule #2.</p>
<p>When you request /articles/1;edit, you&#8217;re simply requesting an editable representation of the resource located at /articles/1.  Just like /articles/1.xml gives you an XML representation of that resource.  When you tack on ;edit, you just return some HTML that the browser renders as a form.</p>
<p>Perhaps some of the mistrust stems from the name &#8220;edit&#8221; being used.  Critics claim that it&#8217;s mixing an action into the URL.  However it&#8217;s pretty clear that no action is taken:</p>
<table class="CodeRay">
<tr>
<td class="line_numbers" title="click to toggle" onclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }">
<pre><tt>
</tt></pre>
</td>
<td class="code">
<pre ondblclick="with (this.style) { overflow = (overflow == 'auto' || overflow == '') ? 'visible' : 'auto' }"><span class="i">1</span>.million.times { <span class="co">GET</span> <span class="rx"><span class="dl">/</span><span class="k">articles</span><span class="dl">/</span></span><span class="i">1</span>;edit }</pre>
</td>
</tr>
</table>
<p>Part of the beauty of the web is that GET requests are guaranteed to be non-destructive.<sup>[1]</sup>  So no matter how many times you get /articles/1;edit, you&#8217;ll never modify it, you&#8217;ll never create another article, you won&#8217;t accidentally delete it, you won&#8217;t trigger a notification that mucks with some other resource&#8230;nothing happens.  There is no action.  You just get the article, exactly like you wanted to do.  And hey, your browser is showing you a form so you can edit it.</p>
<p>If you don&#8217;t like ;edit, there&#8217;s a clean alternative:</p>
<pre><code>http://example.com/articles/1.form</code></pre>
<p>With that URL, it&#8217;s pretty clear that you&#8217;re not doing anything to the article, you&#8217;re just getting a form representation of it.  Nothing more, nothing less.</p>
<p>When I first read Dave&#8217;s article and thought of that naming convention, the ;edit-as-representation-identifier concept seemed too trivial to spend any time on.  However it seems like there&#8217;s a lot of misunderstanding about what it means.  Maybe we should in fact move to an extension like .form to help drive the thinking in the right direction.  That&#8217;s what <a href="http://rspec.rubyforge.org/">RSpec</a> does to get us away from a TDD-as-testing mindset to a <a href="http://www.amazon.com/Test-Driven-Development-Practical-Guide/dp/0131016490/ref=pd_bbs_sr_2/102-6008414-9638531?ie=UTF8&amp;s=books&amp;qid=1176254868&amp;sr=1-2">TDD-as-design</a> one.</p>
<hr />
<ol>
<li>Of course it doesn&#8217;t <i>guarantee</i> anything, but it does if you&#8217;re using the web <i>correctly</i>.</li>
</ol>
