---
layout: post
title: Spikes, Test-after, and Learning How to Test
date: 2008-12-21 14:49:34.000000000 -07:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1443685970'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:3:"151";s:5:"score";s:17:"26.24343998605978";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:2:"99";s:5:"score";s:18:"19.457781721938574";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:4:"1101";s:5:"score";s:18:"19.208805753530132";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:3:"186";s:5:"score";s:18:"15.601807356319872";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"166";s:5:"score";s:18:"13.898763391783657";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:2:"88";s:5:"score";s:18:"12.739897092756284";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:3:"246";s:5:"score";s:18:"12.692612677087169";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:3:"190";s:5:"score";s:18:"12.692612677087169";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
</p>
<p>Last month, I had the pleasure of sitting on a panel on software</p>
<p>testing along with <a href="http://tammersaleh.com/">Tammer Saleh</a>, <a href="http://smartic.us/">Bryan</a></p>
<p>Liles, and <a href="http://sandimetz.com/">Sandi Metz</a>.</p>
<p>It was a lot of fun.  They&#8217;re a great group of folks and we had plenty</p>
<p>of interesting discussion about testing.</p></p>
<p>One of the questions we talked about was, &#8220;Bryan says to <a href="http://smartic.us/2008/8/15/tatft-i-feel-a-revolution-coming-on">test all the</a></p>
<p>fucking</p>
<p>time.</p>
<p>ALL the time?  Really?  What about when writing</p>
<p><a href="http://c2.com/xp/SpikeSolution.html">spikes</a>?&#8221;</p>
<p>Tammer suggested that you write your spike without tests and comment out all the code</p>
<p>when you&#8217;re done.  You then start writing tests and uncomment only the</p>
<p>code that you need to make it pass, refactoring along the way.  I love</p>
<p>this strategy when dealing with <a href="http://my.safaribooksonline.com/0131177052">existing, untested production</a></p>
<p>code, but when Obie asked</p>
<p>if I had any thoughts, my response was, &#8220;Um, I basically hate that</p>
<p>idea.&#8221;</p></p>
<p>TDD and spikes are design tools.  Test-driving your code is effective</p>
<p>with &#8220;design in the small,&#8221; helping you build objects that are</p>
<p>cohesive, loosely-coupled, and communicate via <a href="http://c2.com/cgi/wiki/wiki?IntentionRevealingNames">intention-revealing</a></p>
<p>interfaces.  In</p>
<p>order to do this effectively though, you typically have to have some</p>
<p>idea of what you&#8217;re going to build.  Personally, I find TDD to be an</p>
<p>excellent exploratory/discovery tool, but even I have a very tough</p>
<p>time being effective when I work with objects at a low-level if I</p>
<p>don&#8217;t have a higher-level picture in my mind.  When that picture is</p>
<p>fuzzy or blank, spikes become invaluable.  I can just hack my way to a</p>
<p>prototype.  The code quality doesn&#8217;t really matter, because my main</p>
<p>goal is answering the question &#8220;how the hell am I going to do this?&#8221;</p></p>
<p>When I&#8217;m through spiking, I throw it away.  Or at least commit it to a</p>
<p>temporary branch so I can reference it if I need to.  I want to be</p>
<p>free from that code so I can combine the insight I&#8217;ve received from</p>
<p>the spike with the usual design benefits of TDD.  If I leave that code</p>
<p>in place, it&#8217;s too easy for me to think that it&#8217;s good enough if I</p>
<p>just get it under test now.  That&#8217;s not how you get the max benefit</p>
<p>from TDD.</p>
<p>BUT</p></p>
<p>Commenting out the code and then writing tests does give you a degree</p>
<p>of freedom that I hadn&#8217;t thought of during that panel.  Probably my</p>
<p>favorite thing about TDD is that it lets me mentally separate the What</p>
<p>from the How.  Figuring out which tests to write - specifying the</p>
<p>What - is frequently more difficult than making them pass.  Tammer&#8217;s</p>
<p>approach gives you a great opportunity to write the tests you wish</p>
<p>could have written before&#8230;without the extra work of having to make</p>
<p>them pass.  You can get moving pretty quickly, writing a test and</p>
<p>uncommenting a couple lines, rinse, repeat, with only occasional</p>
<p>slowdowns as you nudge the implementation a bit.</p></p>
<p>Another thing that didn&#8217;t dawn on me until recently is that the good</p>
<p>TDDers I&#8217;ve met are all good hackers as well.  I suspect it&#8217;s because</p>
<p>good hackers quickly learn that the easiest way to make sure your code</p>
<p>still works is to write automated tests, and the easiest way to write</p>
<p>automated tests is to write them before the code.  What this means is</p>
<p>that when Tammer writes a spike, the end result is going to be pretty</p>
<p>good code that gets the job done.  From there, he writes the tests to</p>
<p>give him a safety net which he can use to refactor the code to make it</p>
<p>even better.</p>
<h2>Test-after as a means of learning how to test</h2></p>
<p>Writing code and testing it afterwards isn&#8217;t just for spikes though.</p>
<p>I think it can also be a useful strategy for learning how to write</p>
<p>tests.  If you&#8217;ve been coding Ruby for the last two years but don&#8217;t</p>
<p>know RSpec (or test::unit, or shoulda, etc..), you&#8217;re going to have to</p>
<p>go through the learning curve, plain and simple.  This means learning</p>
<p>new syntax, libraries and idioms.  On the RSpec list, I occasionally</p>
<p>see questions like, &#8220;I wrote this test but it&#8217;s failing, but I know</p>
<p>the code works fine, why is RSpec stupid?&#8221;  The problem comes from</p>
<p>thinking that the author wrote the test correctly in the first</p>
<p>place&#8230;clearly that&#8217;s not the case.  By writing the code first and</p>
<p>then the tests, you get the effect of TDD applied to learning a</p>
<p>testing framework.</p></p>
<p>Now I want to make it absolutely clear that I don&#8217;t advocate</p>
<p>test-after as your main strategy.  I do think that it can be</p>
<p>combined with spikes to write well-designed production code.  And I</p>
<p>think it can be useful for learning <em>how</em> to test as well.  The fact</p>
<p>is that TDD is hard to do well, and as with any difficult technique</p>
<p>requires practice.  You&#8217;re not going to get there overnight, and it&#8217;s</p>
<p>perfectly fine to fudge the process if that&#8217;s what it takes to</p>
<p>develop your skills.  Just be sure to practice real TDD too, so you</p>
<p>can eventually be test-driving by default.</p>
