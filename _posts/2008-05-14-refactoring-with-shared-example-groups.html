---
layout: post
title: Refactoring With Shared Example Groups
date: 2008-05-14 14:15:30.000000000 -06:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1442061541'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:3:"190";s:5:"score";s:18:"12.593652562643186";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:3:"151";s:5:"score";s:18:"12.593652562643186";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"970";s:5:"score";s:18:"11.910153975240453";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:3:"199";s:5:"score";s:18:"11.207358201523295";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:2:"59";s:5:"score";s:18:"10.288293542794001";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"172";s:5:"score";s:17:"9.821063840403404";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:3:"166";s:5:"score";s:17:"9.821063840403404";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:3:"125";s:5:"score";s:17:"9.821063840403404";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>One common question when performing a <a href="http://www.refactoring.com/catalog/moveMethod.html">Move Method</a> or <a href="http://www.refactoring.com/catalog/pullUpMethod.html">Pull Up Method</a> refactoring is what to do with the tests.  Consider the following simple Order class:</p>
<p><script src="http://gist.github.com/495291.js?file=gistfile1.rb"></script>
<p>We are interested in extracting <em>#print_receipt</em> and moving it to a Receipt class.  Here are the existing specs:</p>
<p><script src="http://gist.github.com/495294.js?file=gistfile1.rb"></script><br />
<h2>A simple Move Method refactoring</h2>
<p>Refactoring to use a Receipt class is trivial.  We start by creating a Receipt, passing in the Order object.</p>
<p><script src="http://gist.github.com/495296.js?file=gistfile1.rb"></script>
<p>Next we copy <em>#print_receipt</em> to Receipt and change the receiver of the <em>#customer</em>, <em>#shipping_address</em>, and <em>#total_price</em> methods to be the Order:</p>
<p><script src="http://gist.github.com/495298.js?file=gistfile1.rb"></script>
<p>And finally we delegate <em>Order#print_receipt</em> to the new Receipt class:</p>
<p><script src="http://gist.github.com/495300.js?file=gistfile1.rb"></script><br />
<h2>What about the tests?</h2>
<p>This is a typical refactoring, and one of the reasons we have unit tests is to enable us to perform such refactorings.  However there&#8217;s one question remaining - what should we do about the tests?</p>
<p>There are usually two choices at this point:</p>
<ul>
<li>Do nothing.  We haven&#8217;t changed the system&#8217;s behavior, and all the tests are green, so we can just leave things as they are</li>
<li>Copy the tests into receipt_spec.rb and modify them to work for receipts</li>
</ul>
<p>Doing nothing is an okay option.  We&#8217;ve done a pure refactoring, after all, so there&#8217;s nothing driving the addition/modification of specs.  There currently aren&#8217;t any other clients of Receipt, so it doesn&#8217;t necessarily need to be fully spec&#8217;d out.  I&#8217;ve read Michael Feathers suggest leaving the tests alone for the time being, and then writing/moving tests any time you use untested code.  More concretely, I might leave all the tests alone, and then if I ever wrote more code that used Receipt#print down the road then I&#8217;d write specs for it.</p>
<p>While I don&#8217;t think that leaving the specs alone is bad, I don&#8217;t think it&#8217;s particularly nice either.  Specs have four major benefits:</p>
<ul>
<li>help drive the design of code</li>
<li>provide regression tests</li>
<li>enable refactoring</li>
<li>serve as documentation</li>
</ul>
<p>The last one is especially important for me because I never comment or document my code.  That&#8217;s not an exaggeration either, I really mean <em>never</em>.</p>
<p>It would be nice if we had some documentation around Receipt#print in the form of executable specs.  The traditional way to do this would be to copy the specs from <em>Order#print_receipt</em> and modify them to work for a Receipt.  (You might also move the specs <em>before</em> moving the implementation, or you might change the <em>Order#print_receipt</em> specs to use a mock instead.  Those are decisions that are not that interesting in the context of this post)</p>
<h2>Introducing shared example groups</h2>
<p>The only problem with copying the specs is that doing so introduces duplication.  Some amount of duplication in specs is acceptable and sometimes even desirable, but in this case we&#8217;d have functional duplication which is almost always bad.</p>
<p>We can take advantage of shared example groups to add coverage to Receipt without introducing bad duplication.  To do this, we&#8217;ll extract a shared example group out of the existing example group in order_spec.rb.</p>
<p>Because we&#8217;re just printing to a buffer, we can reuse nearly all of the specs.  The first step is to generalize the receipt printing code in the spec:</p>
<p><script src="http://gist.github.com/495301.js?file=gistfile1.rb"></script>
<p>All I&#8217;ve done in this case is extracted the receipt printing to a method called <em>#print_receipt</em>.  Now I&#8217;ll create a shared example group and move the first example to it:</p>
<p><script src="http://gist.github.com/495305.js?file=gistfile1.rb"></script>
<p>Those all run, so now we can move the rest of the specs over:</p>
<p><script src="http://gist.github.com/495309.js?file=gistfile1.rb"></script>
<p>Now to write the spec for <em>Receipt#print</em>, we just need to write an example group, do a bit of setup and implement <em>#print_receipt</em>, and use the shared example group:</p>
<p><script src="http://gist.github.com/495310.js?file=gistfile1.rb"></script><br />
<h2>Steps for refactoring to shared example groups</h2>
<p>There we go, a nice way to handle refactoring specs along with production code.  Briefly, the steps are:</p>
<ol>
<li>Extract behavior to a method in original example group</li>
<li>Create a new shared example group</li>
<li>Make original EG behave like new SEG</li>
<li>Move examples to SEG</li>
</ol>
<h2>Some final thoughts</h2>
<p>I didn&#8217;t make these specs as clean as I could have, because I just wanted to show you the basics of this refactoring.  The two things that concern me about the example code as I&#8217;ve left it are that the shared example group uses instance variables defined in the concrete example groups, and that there&#8217;s duplication in setup between the Order and Receipt specs.</p>
<p>The first problem is pretty simple.  Just do <em>attr_reader :receipt_output</em> in both example groups and change the shared example group to use that method instead.  This way it&#8217;s relying on an API instead of mixing up API and instance data.</p>
<p>The second problem could be handled a number of ways.  You could move some of the setup code into the shared example group itself.  You might be using something like fixture_scenarios on your project, or maybe you&#8217;re using an object mother.  And of course in the case of receipt_spec.rb, you might use a mock Order instead of a real one.</p>
<p>I really like this pattern for certain refactorings, where the code is organized in one place but executed in multiple places (think of pushing an instance method up to a superclass).  We can lean on our test suite to do the refactoring, and then easily provide direct coverage for any new methods and classes.</p>
<p>My only gripe about this style is that the tests are a little removed from the code.  Instead of just looking at receipt_spec.rb, I have to go look at where the shared example group is defined.  However that is much better than before, where <em>Receipt#print</em> was tested, but the specs were very far removed from it, living in order_spec.rb.  In this case, the reduction of duplication is a big win that outweights the little bit of indirection.</p>
<p><em>Special thanks to Nick Kallen and Jonathan Barnes for a good discussion on moving specs when refactoring code</em></p>
