---
layout: post
title: Sometimes a Tool Isn't Just a Tool
date: 2008-11-12 14:45:31.000000000 -07:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1442134353'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:2:"99";s:5:"score";s:18:"14.743174708197115";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:4:"1106";s:5:"score";s:18:"11.381380955502555";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:4:"1101";s:5:"score";s:18:"10.716695269275187";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:3:"160";s:5:"score";s:17:"9.585497769076845";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"184";s:5:"score";s:17:"9.231858809948626";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:2:"53";s:5:"score";s:17:"9.231858809948626";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:3:"431";s:5:"score";s:17:"8.567173123721258";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:2:"78";s:5:"score";s:17:"8.420928593718505";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
</p>
<p>Dan Croak recently talked about the <a href="http://giantrobots.thoughtbot.com/2008/11/7/a-critical-look-at-the-current-state-of-ruby-testing">state of Ruby</a></p>
<p>testing.</p>
<p>He points out the many frameworks available, and examines some ideas</p>
<p>that he feels are misused.  In it, he makes one major assertion that I</p>
<p>strongly disagree with:</p></p>
<div class="quote"><q>There&#8217;s a simple fact that no one seems to be<br />
</q>
<p>talking about: <b>all of these testing tools are solutions to</b></p>
<p>non-existant problems.</p>
</div>
<p>(emphasis his)</p></p>
<p>I&#8217;d like to start off with some simple evidence that refutes this -</p>
<p>take a look at the people heading these alternate testing frameworks.</p>
<p>Guys like David Chelimsky, Tammer Saleh, Jeremy McNally, and Jay</p>
<p>Fields.  Now they&#8217;re not perfect, of course, but they have a</p>
<p>reputation for being smart and highly productive.  I don&#8217;t buy that</p>
<p>they&#8217;d all waste tons of time building solutions to non-existant</p>
<p>problems (RSpec is a couple years old now, and shoulda is about to</p>
<p>celebrate its first birthday).  So what is the problem they&#8217;re trying</p>
<p>to solve?</p>
<h1>A whole stack of problems</h1>
<p><img src="assets/venn_programmers.gif" /></p>
<p>(Venn diagram jacked from <a href="http://gilesbowkett.blogspot.com/2008/10/i-have-too-many-books.html">Giles Bowkett</a>)</p></p>
<p>With each of these frameworks, the goal is to make that little red</p>
<p>circle expand to the same size as the big yellow one.  And you can see</p>
<p>that in the histories of these projects.  Let&#8217;s take a quick look at</p>
<p>how RSpec tries to make that happen:</p>
<h2>Why don&#8217;t programmers write tests?</h2></p>
<p>There are technical, social and political reasons that programmers</p>
<p>don&#8217;t write tests.  One technical reason that they don&#8217;t is because</p>
<p>Test::Unit syntax doesn&#8217;t make much sense (and yes, I get that it just</p>
<p>has to be learned, but assert:testing :: orm:OOP).  RSpec provided a</p>
<p>syntax that made more sense, made it more accessible.</p>
<h2>I&#8217;m testing&#8230;now what?</h2></p>
<p>Once programmers start writing tests, they get hooked into this</p>
<p>community.  They ask questions on the mailing list and are met with</p>
<p>little hints such as &#8220;if you were to write the test first, your life</p>
<p>would be simpler.&#8221;  Using a specialized testing framework is a gateway</p>
<p>drug to a community that has pretty good ideas on what makes</p>
<p>high-quality software and how to achieve it.</p>
<h2>Sharpening the saw</h2></p>
<p>Doing TDD doesn&#8217;t mean you&#8217;re doing it well.  Again, this is where the</p>
<p>community is really helpful.  It&#8217;s also another place where a</p>
<p>framework&#8217;s syntax guides you.  One of my favorite things about RSpec</p>
<p>is the extreme to which it takes the idea of specifying behavior:</p>
<p><script src="http://gist.github.com/495520.js?file=gistfile1.rb"></script></p>
<p>Some people hate the magic going on here - they say that you have to</p>
<p>know little details about the framework to know that it&#8217;s essentially</p>
<p>rewriting:</p>
<p><script src="http://gist.github.com/495522.js?file=gistfile1.rb"></script></p>
<p>But that&#8217;s precisely what makes it so awesome!  We&#8217;re interested in</p>
<p>the object&#8217;s <em>behavior</em>, and when specifying behavior it turns out</p>
<p>that the interface is actually a bit noisy.  Does it really matter</p>
<p>that there&#8217;s a method named <em>#overdrawn?</em> or that <em>team.players</em> is a</p>
<p>collection?  Well, yeah, but not in this narrow context.</p></p>
<p>Others may disagree as to how effective RSpec is at solving these</p>
<p>problems, but that&#8217;s not the point.  The point is to recognize these</p>
<p>problems and to try to do something about them.</p>
<h1>The real problem is Responsibility</h1></p>
<p>There&#8217;s one thing that I haven&#8217;t addressed yet, and that is why</p>
<p>increase the number of programmers who do TDD well?  There&#8217;s a lot of</p>
<p>literature on the benefits of TDD, so I&#8217;m not going to rehash it.  I</p>
<p>would like to reframe some of these benefits in the context of</p>
<p>Responsibility.</p>
<h2>My #1 Responsibility - Don&#8217;t be an Asshole</h2></p>
<p>When I was younger people called this the Golden Rule.  I&#8217;ve since</p>
<p>learned that the Golden Rule, as traditionally phrased, is missing</p>
<p>something.  The simplest way to explain that is that while I would not</p>
<p>want someone to punch me in the face, in certain situations the most</p>
<p>appropriate response is to punch someone else in the face.  The guy</p>
<p>you punched may think you&#8217;re an asshole, but you know in your heart</p>
<p>that it was the right thing to do.</p></p>
<p>Anyway.  When I&#8217;m coding, I have a responsibility to myself and to my</p>
<p>team.  Here are some things I <em>don&#8217;t</em> want to do</p>
<ul>
<li>breaking code that previously worked</li>
<li>writing 500-line methods</li>
<li>tighly coupling objects, making them difficult to change</li>
</ul>
<p>These are all things that I may do which will cause someone at some</p>
<p>point to say, &#8220;Man, Pat sure is an asshole.&#8221;</p></p>
<p>It is my responsibility to keep existing code working, to improve</p>
<p>existing code to make it more maintainable, and to write new code that</p>
<p>functions and is maintainable.  The best way I&#8217;ve found to do this is</p>
<p>to do TDD.  It&#8217;s not the only way, of course, just like GTD isn&#8217;t the</p>
<p>only system for managing your workload.  But it&#8217;s proven to be pretty</p>
<p>damn effective.</p>
<h2>Responsibility != Accountability</h2></p>
<p>Have you ever stopped to ask yourself &#8220;who is responsible for the</p>
<p>success of this software project?&#8221;  It seems like a silly question,</p>
<p>and in your mind you know the answer, but if you take a look around at</p>
<p>the project you&#8217;ll see all kinds of signs that people haven&#8217;t taken</p>
<p>responsibility.</p>
<p>There are two simple ideas that make a project successful:</p>
<ul>
<li>Building the right software</li>
<li>Building the software right</li>
</ul>
<p>Executing them is difficult of course, but if you can figure out the</p>
<p>right software to build and manage to build it right, you&#8217;re going to</p>
<p>be successful.</p></p>
<p>You&#8217;d be amazed though (or not) at how often we lose sight of those</p>
<p>crucial facts.  It seems to me that a lot of systems are necessary to</p>
<p>protect the obvious, lest we take them for granted.  XP tries to</p>
<p>formalize this by creating a clear division of responsibility between</p>
<p>the Customer and Developer.  The Developer is responsible for</p>
<p>building the software right, allowing the Customer to experiment and</p>
<p>tweak his understanding of what is the right software.</p></p>
<p>Acceptance Test-Driven Planning is one tool we can use to help us</p>
<p>build the right software.  It&#8217;s important because while the Customer</p>
<p>may have a good idea of what they want built, that idea frequently</p>
<p>gets lost in translation when working with the developer.  Unmet</p>
<p>expectations are the source of most of the friction in projects I&#8217;ve</p>
<p>worked on.</p></p>
<p>Who&#8217;s to blame though?  Is it the developer&#8217;s job to make sure that he</p>
<p>understands requirements correctly?  Or is it the customer&#8217;s job to</p>
<p>ensure that his expectations are reasonable?  The answer, really, is</p>
<p>that it misses the point.  Figuring all this stuff out is a <b>shared</b></p>
<p>responsibility.</p></p>
<p>You can hold someone accountable, but never responsible.  The only</p>
<p>person you can hold responsible for anything is yourself.  In order</p>
<p>for two people to share responsibility, they must make an agreement</p>
<p>with each other and with themselves to take responsibility.</p></p>
<p>The point of writing acceptance tests is to define the success</p>
<p>criteria for a software product.  The point of doing acceptance</p>
<p>test-driven planning in a systematic manner is to ensure that, despite</p>
<p>all the different things that everyone has to juggle, we continue to</p>
<p>share responsibility so crucial to the success of the project.</p>
<h2>We know about clean code, but what about clean software?</h2></p>
<p>Kent Beck&#8217;s TDD book begins with stating that &#8220;clean code that works&#8221;</p>
<p>should be the goal of any programmer.  Uncle Bob now has a book titled</p>
<p>Clean Code which talks about micro-patterns for writing clean code.</p>
<p>The next logical step is writing clean software.  I think that clean</p>
<p>software can be recognized by three criteria:</p>
<ul>
<li>Meets existing requirements</li>
<li>Doesn&#8217;t do anything that&#8217;s not a requirement</li>
<li>Can be adapted to meet new/changing requirements</li>
</ul>
<p>They all tie together, of course.  If you&#8217;ve got a bunch of unncessary</p>
<p>functionality in the software, it&#8217;s going to take more effort to</p>
<p>change it to meet new or changing requirements.</p></p>
<p>This is where tools like Cucumber come into play.  With Cucumber, you</p>
<p>critically analyze the essential behaviors of the software.  There&#8217;s</p>
<p>nothing abstract about sitting down and writing features.  You have to</p>
<p>think about what the feature is and why you want it - what business</p>
<p>value does it provide?  If you can&#8217;t see what business value a feature</p>
<p>provides, there&#8217;s no reason for it to be in there.</p>
<h2>&#8220;You&#8217;re trying to solve a people problem with technology&#8221;</h2></p>
<p>This is an argument I frequently hear being made against developer</p>
<p>testing, and even more so against acceptance testing, and it&#8217;s always</p>
<p>made with an implicit understanding that this is somehow a bad thing.</p>
<p>True, it&#8217;s often a bad idea to solve people problems with technology.</p>
<p>But it&#8217;s often a great idea to solve people problems with <em>systems</em>.</p>
<p>Knowing what you should do is second-nature for most people.  Actually</p>
<p>doing it, on the other hand, is a whole different story.</p></p>
<p>Let me give you an embarassingly stupid example.  Up until a few</p>
<p>months ago, I would only brush and floss my teeth, and wash my face</p>
<p>before going to sleep a couple nights a week.  I knew I should do it,</p>
<p>but I didn&#8217;t, and I&#8217;m probably not alone in that.  So for a while, I</p>
<p>had a little notecard on my bathroom mirror that said &#8220;1) Brush teeth</p>
<p>2) Floss 3) Wash face.&#8221;  Retarded simple, but massively effective</p>
<p>because it forced me to turn those actions into habit.  It was a</p>
<p>people problem (my laziness) and could have been solved by intense</p>
<p>amounts of self-introspection and discipline, but with a simple system</p>
<p>in place it only took like a week - with essentially no thought or</p>
<p>effort required - to make the changes I wanted.</p></p>
<p>Another important aspect of the system I implemented was that it was</p>
<p>easy to discard.  It probably would have sucked if I had told someone</p>
<p>to come knock on my door every night and remind me to brush my teeth,</p>
<p>and to continue to do it regardless of how much I protested or said I</p>
<p>didn&#8217;t need the reminder (I&#8217;ve read about Ulysses and the Sirens, so I</p>
<p>know how important drastic measures are).  But no, when I had no use</p>
<p>for my system I just tossed the card into the trash and went on with</p>
<p>my life.</p></p>
<p>Testing frameworks are similar in that they&#8217;re relatively lightweight.</p>
<p>You could be working with RSpec on a Rails project for two years, one</p>
<p>day decide that you hate RSpec, and you can simply &#8220;rm -rf spec&#8221; to</p>
<p>get rid of it.  It&#8217;s possible to develop a framework fetish where you</p>
<p>spend hours and hours tweaking a tool to no benefit.  I hear many</p>
<p>opponents of certain testing frameworks bemoan this fact, but they</p>
<p>never seem to get that this social dependency is way easier to</p>
<p>identify and solve than a technical one.  If it turns out that Rails</p>
<p>isn&#8217;t up to the task anymore 2 years into a project, good luck</p>
<p>switching to something else.</p>
<h1>Ignore the cynics, do cool shit</h1></p>
<p>When I talk about this stuff with people, I&#8217;m often met with</p>
<p>cynicism [1].  There are too many tools, or people are interested in</p>
<p>hyping the next *DD, etc.  The first thing I point out is that nobody</p>
<p>forces you to use them.  Secondly, the variety of tools available</p>
<p>points to the fact that there isn&#8217;t some Grand Unified Theory of</p>
<p>software, but rather that there are many, many different approaches</p>
<p>that can yield results.  It&#8217;s up to you to figure out the tools and</p>
<p>techniques that work best for you.  And yes, that means creating them</p>
<p>when you don&#8217;t find anything good enough.  Finally, the &#8220;splintering&#8221;</p>
<p>that Dan talks about is most certainly a good thing.  Just look at the</p>
<p>communities surrounding RSpec and shoulda, and the cool ideas and</p>
<p>discussions that come out of them.</p>
<hr />
<p>[1] <i>I want to point out that I&#8217;m NOT calling Dan a cynic, as I think</i></p>
<p>he&#8217;s done a good job of explaining some issues with the testing in the</p>
<p>Ruby community.</p></p>
<p>[1b] <i>I think the difference between a cynic and a</i></p>
<p>critic is that a critic makes reasonable arguments, while a cynic</p>
<p>makes strawman arguments and is an asshole about it.</p>
