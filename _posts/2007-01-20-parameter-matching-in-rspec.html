---
layout: post
title: Parameter Matching in RSpec
date: 2007-01-20 23:57:45.000000000 -07:00
categories: []
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '2'
  _wp_rp_related_posts_query_result_cache_expiration: '1442077093'
  _wp_rp_related_posts_query_result_cache_4: a:8:{i:0;O:8:"stdClass":2:{s:7:"post_id";s:2:"65";s:5:"score";s:18:"18.966927711190827";}i:1;O:8:"stdClass":2:{s:7:"post_id";s:3:"210";s:5:"score";s:18:"17.789439589253245";}i:2;O:8:"stdClass":2:{s:7:"post_id";s:3:"123";s:5:"score";s:18:"13.677565647337929";}i:3;O:8:"stdClass":2:{s:7:"post_id";s:2:"57";s:5:"score";s:17:"13.36062496553231";}i:4;O:8:"stdClass":2:{s:7:"post_id";s:3:"162";s:5:"score";s:17:"13.24844603243712";}i:5;O:8:"stdClass":2:{s:7:"post_id";s:3:"127";s:5:"score";s:18:"13.193861747681794";}i:6;O:8:"stdClass":2:{s:7:"post_id";s:2:"44";s:5:"score";s:18:"12.914337862903892";}i:7;O:8:"stdClass":2:{s:7:"post_id";s:3:"117";s:5:"score";s:18:"12.018288417863761";}}
author:
  login: pat
  email: patmaddox@me.com
  display_name: pat
  first_name: Pat
  last_name: Maddox
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>I&#8217;m working on a proxy class that wraps up a remote API.  The calls look something like &#8220;http://host/api/message?name=messageName&amp;param1=foo&amp;param2=foo&#8221;.  Here&#8217;s a spec for one such call:</p>
<p><script src="http://gist.github.com/482357.js?file=gistfile1.rb"></script>
<p>And the code that makes it run:</p>
<p><script src="http://gist.github.com/482358.js?file=gistfile1.rb"></script></p>
<p>There are two major problems with this</p>
<p>30792516dd361e2adde8789e03abdade</p>
<p>Let&#8217;s say we want to factor out the HTTP.start call.  We want a method, #message, which takes the string name of the message and some arbitrary parameters.  #progress could look like:</p>
<p><script src="http://gist.github.com/482360.js?file=gistfile1.rb"></script>
<p>#message just builds up the proper URL, parses the response, and returns the relevant parts.</p>
<p>What&#8217;s wrong with that?  Well, since we&#8217;re passing in a hash, the order of the parameters isn&#8217;t guaranteed.  This means when you run the spec, the generated URL often won&#8217;t be the same as what you specify, even if all the parameters are there.  We could solve this by passing an array instead&#8230;but hashes of symbols/value pairs is pretty sexy, and has become the standard way of passing around arbitrary parameters (at least when working with Rails).  We shouldn&#8217;t have to give that up because of our specing framework.</p>
<p>RSpec already lets you match the result of something:</p>
<p><script src="http://gist.github.com/482361.js?file=gistfile1.rb"></script>
<p>But how do you specify that a parameter passed into a method matches some particular pattern?  Turns out all you have to do is pass the regexp into the with() method:</p>
<p><script src="http://gist.github.com/482362.js?file=gistfile1.rb"></script>
<p>This lets us turn the original spec into:</p>
<p><script src="http://gist.github.com/482363.js?file=gistfile1.rb"></script>
<p>All of a sudden we&#8217;ve got detailed, <i>useful</i> specs, and now we can easily factor out a #message method to get rid of boilerplate.</p>
<p>I don&#8217;t know if this is an intended feature of RSpec, or if it&#8217;s just a pleasant consequence of how Ruby handles comparisons between regexps and other objects.  I imagine it&#8217;s intended, but it&#8217;s not in the docs&#8230;so I thought you guys might like to know this useful trick.</p>
